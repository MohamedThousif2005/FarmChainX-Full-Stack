package com.farmchainx.backend.controller;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.farmchainx.backend.dto.ProductDTO;
import com.farmchainx.backend.entity.Product;
import com.farmchainx.backend.service.ProductService;

import jakarta.annotation.PostConstruct;

@RestController
@RequestMapping("/api/products")
@CrossOrigin(origins = "*")
public class ProductController {
    
    @Autowired
    private ProductService productService;

    private final String UPLOAD_DIR = "uploads/products/";
    
    // Add this method to auto-create directory on startup
    @PostConstruct
    public void init() {
        try {
            Path uploadPath = Paths.get(UPLOAD_DIR);
            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
                System.out.println("✅ Created upload directory: " + uploadPath.toAbsolutePath());
            }
        } catch (IOException e) {
            System.err.println("❌ Could not create upload directory: " + e.getMessage());
        }
    }
    @PostMapping(value = "/distributor/{distributorId}", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> addProduct(
            @PathVariable Long distributorId,
            @RequestParam("name") String name,
            @RequestParam("description") String description,
            @RequestParam("category") String category,
            @RequestParam("price") Double price,
            @RequestParam("quantity") Integer quantity,
            @RequestParam("unit") String unit,
            @RequestParam(value = "image", required = false) MultipartFile image) {
        
        try {
            ProductDTO productDTO = new ProductDTO();
            productDTO.setName(name);
            productDTO.setDescription(description);
            productDTO.setCategory(category);
            productDTO.setPrice(price);
            productDTO.setQuantity(quantity);
            productDTO.setUnit(unit);

            // Handle image upload
            if (image != null && !image.isEmpty()) {
                String imageUrl = saveImage(image);
                productDTO.setImageUrl(imageUrl);
            }

            Product product = productService.addProduct(productDTO, distributorId);
            return ResponseEntity.ok(product);
            
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to add product: " + e.getMessage())
            );
        }
    }

    @GetMapping("/images/{filename:.+}")
    public ResponseEntity<byte[]> getImage(@PathVariable String filename) {
        try {
            Path filePath = Paths.get(UPLOAD_DIR).resolve(filename).normalize();
            
            // Check if file exists
            if (!Files.exists(filePath)) {
                return ResponseEntity.notFound().build();
            }
            
            byte[] imageBytes = Files.readAllBytes(filePath);
            
            String contentType = Files.probeContentType(filePath);
            if (contentType == null) {
                contentType = "application/octet-stream";
            }
            
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(contentType))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + filename + "\"")
                    .body(imageBytes);
                    
        } catch (IOException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @GetMapping("/distributor/{distributorId}")
    public ResponseEntity<List<ProductDTO>> getDistributorProducts(@PathVariable Long distributorId) {
        List<ProductDTO> products = productService.getProductsByDistributor(distributorId);
        return ResponseEntity.ok(products);
    }
    
    @GetMapping("/available")
    public ResponseEntity<List<ProductDTO>> getAllAvailableProducts() {
        List<ProductDTO> products = productService.getAllAvailableProducts();
        return ResponseEntity.ok(products);
    }
    
    @PutMapping(value = "/{productId}", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> updateProduct(
            @PathVariable Long productId,
            @RequestParam("name") String name,
            @RequestParam("description") String description,
            @RequestParam("category") String category,
            @RequestParam("price") Double price,
            @RequestParam("quantity") Integer quantity,
            @RequestParam("unit") String unit,
            @RequestParam(value = "image", required = false) MultipartFile image) {
        
        try {
            ProductDTO productDTO = new ProductDTO();
            productDTO.setName(name);
            productDTO.setDescription(description);
            productDTO.setCategory(category);
            productDTO.setPrice(price);
            productDTO.setQuantity(quantity);
            productDTO.setUnit(unit);

            // Handle image upload for update
            if (image != null && !image.isEmpty()) {
                String imageUrl = saveImage(image);
                productDTO.setImageUrl(imageUrl);
            }

            Product product = productService.updateProduct(productId, productDTO);
            return ResponseEntity.ok(product);
            
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to update product: " + e.getMessage())
            );
        }
    }
    
    @DeleteMapping("/{productId}")
    public ResponseEntity<?> deleteProduct(@PathVariable Long productId) {
        try {
            productService.deleteProduct(productId);
            return ResponseEntity.ok(Map.of("message", "Product deleted successfully"));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to delete product: " + e.getMessage())
            );
        }
    }

    private String saveImage(MultipartFile image) throws IOException {
        // Create upload directory if it doesn't exist
        Path uploadPath = Paths.get(UPLOAD_DIR);
        if (!Files.exists(uploadPath)) {
            Files.createDirectories(uploadPath);
        }
        
        // Generate unique filename
        String originalFileName = image.getOriginalFilename();
        String fileExtension = "";
        if (originalFileName != null && originalFileName.contains(".")) {
            fileExtension = originalFileName.substring(originalFileName.lastIndexOf("."));
        }
        
        String fileName = System.currentTimeMillis() + "_" + 
                         (originalFileName != null ? originalFileName.replaceAll("[^a-zA-Z0-9.-]", "_") : "product");
        String filePath = UPLOAD_DIR + fileName;
        
        // Save file
        Path targetLocation = uploadPath.resolve(fileName);
        Files.copy(image.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
        
        return "/api/products/images/" + fileName;
    }

    // Keep the original JSON endpoint for backward compatibility
    @PostMapping(value = "/distributor/{distributorId}/json", consumes = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<?> addProductJson(@RequestBody ProductDTO productDTO, 
                                          @PathVariable Long distributorId) {
        try {
            Product product = productService.addProduct(productDTO, distributorId);
            return ResponseEntity.ok(product);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to add product: " + e.getMessage())
            );
        }
    }

    // Add endpoint to get product by ID for editing
    @GetMapping("/{productId}")
    public ResponseEntity<?> getProductById(@PathVariable Long productId) {
        try {
            Product product = productService.getProductById(productId);
            return ResponseEntity.ok(product);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to get product: " + e.getMessage())
            );
        }
    }
}