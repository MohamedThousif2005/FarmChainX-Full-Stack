package com.farmchainx.backend.controller;

import com.farmchainx.backend.dto.ProductDTO;
import com.farmchainx.backend.entity.Product;
import com.farmchainx.backend.service.ProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import jakarta.annotation.PostConstruct;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/products")
@CrossOrigin(origins = "*")
public class ProductController {
    
    @Autowired
    private ProductService productService;

    private final String UPLOAD_DIR = "uploads/products/";
    
    @PostConstruct
    public void init() {
        try {
            Path uploadPath = Paths.get(UPLOAD_DIR);
            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
                System.out.println("‚úÖ Created upload directory: " + uploadPath.toAbsolutePath());
            } else {
                System.out.println("üìÅ Upload directory exists: " + uploadPath.toAbsolutePath());
            }
        } catch (IOException e) {
            System.err.println("‚ùå Could not create upload directory: " + e.getMessage());
        }
    }
    
    @PostMapping(value = "/distributor/{distributorId}", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> addProduct(
            @PathVariable Long distributorId,
            @RequestParam("name") String name,
            @RequestParam("description") String description,
            @RequestParam("category") String category,
            @RequestParam("price") Double price,
            @RequestParam("quantity") Integer quantity,
            @RequestParam("unit") String unit,
            @RequestParam(value = "image", required = false) MultipartFile image) {
        
        try {
            System.out.println("üì¶ Adding product for distributor: " + distributorId);
            
            ProductDTO productDTO = new ProductDTO();
            productDTO.setName(name);
            productDTO.setDescription(description);
            productDTO.setCategory(category);
            productDTO.setPrice(price);
            productDTO.setQuantity(quantity);
            productDTO.setUnit(unit);

            // Handle image upload
            if (image != null && !image.isEmpty()) {
                System.out.println("üñºÔ∏è Image received: " + image.getOriginalFilename() + ", Size: " + image.getSize());
                String imageUrl = saveImage(image);
                productDTO.setImageUrl(imageUrl);
                System.out.println("‚úÖ Image saved with URL: " + imageUrl);
            } else {
                System.out.println("‚ÑπÔ∏è No image provided");
                productDTO.setImageUrl("/api/products/images/default-product.png");
            }

            Product product = productService.addProduct(productDTO, distributorId);
            System.out.println("‚úÖ Product added successfully with ID: " + product.getId());
            
            return ResponseEntity.ok(product);
            
        } catch (Exception e) {
            System.err.println("‚ùå Error adding product: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to add product: " + e.getMessage())
            );
        }
    }

    @GetMapping("/distributor/{distributorId}")
    public ResponseEntity<List<ProductDTO>> getDistributorProducts(@PathVariable Long distributorId) {
        try {
            System.out.println("üì• Fetching products for distributor: " + distributorId);
            List<ProductDTO> products = productService.getProductsByDistributor(distributorId);
            System.out.println("‚úÖ Found " + products.size() + " products");
            
            // Log image URLs for debugging
            for (ProductDTO product : products) {
                System.out.println("üì∏ Product: " + product.getName() + ", Image URL: " + product.getImageUrl());
            }
            
            return ResponseEntity.ok(products);
        } catch (Exception e) {
            System.err.println("‚ùå Error fetching products: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(List.of());
        }
    }
    
    @PutMapping(value = "/{productId}", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> updateProduct(
            @PathVariable Long productId,
            @RequestParam("name") String name,
            @RequestParam("description") String description,
            @RequestParam("category") String category,
            @RequestParam("price") Double price,
            @RequestParam("quantity") Integer quantity,
            @RequestParam("unit") String unit,
            @RequestParam(value = "image", required = false) MultipartFile image) {
        
        try {
            System.out.println("üîÑ Updating product ID: " + productId);
            
            ProductDTO productDTO = new ProductDTO();
            productDTO.setName(name);
            productDTO.setDescription(description);
            productDTO.setCategory(category);
            productDTO.setPrice(price);
            productDTO.setQuantity(quantity);
            productDTO.setUnit(unit);

            // Handle image upload for update
            if (image != null && !image.isEmpty()) {
                System.out.println("üñºÔ∏è New image received for update: " + image.getOriginalFilename());
                String imageUrl = saveImage(image);
                productDTO.setImageUrl(imageUrl);
            }

            Product product = productService.updateProduct(productId, productDTO);
            System.out.println("‚úÖ Product updated successfully: " + product.getId());
            
            return ResponseEntity.ok(product);
            
        } catch (Exception e) {
            System.err.println("‚ùå Error updating product: " + e.getMessage());
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to update product: " + e.getMessage())
            );
        }
    }
    
    @DeleteMapping("/{productId}")
    public ResponseEntity<?> deleteProduct(@PathVariable Long productId) {
        try {
            String result = productService.deleteProduct(productId);
            return ResponseEntity.ok(Map.of("message", result));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to delete product: " + e.getMessage())
            );
        }
    }

    @GetMapping("/{productId}")
    public ResponseEntity<?> getProductById(@PathVariable Long productId) {
        try {
            ProductDTO product = productService.getProductById(productId);
            return ResponseEntity.ok(product);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to get product: " + e.getMessage())
            );
        }
    }

    private String saveImage(MultipartFile image) throws IOException {
        // Create upload directory if it doesn't exist
        Path uploadPath = Paths.get(UPLOAD_DIR);
        if (!Files.exists(uploadPath)) {
            Files.createDirectories(uploadPath);
        }
        
        // Generate unique filename
        String originalFileName = image.getOriginalFilename();
        String fileExtension = "";
        if (originalFileName != null && originalFileName.contains(".")) {
            fileExtension = originalFileName.substring(originalFileName.lastIndexOf("."));
        }
        
        String fileName = System.currentTimeMillis() + "_" + 
                         (originalFileName != null ? 
                          originalFileName.replaceAll("[^a-zA-Z0-9.-]", "_") : "product");
        
        // Save file
        Path targetLocation = uploadPath.resolve(fileName);
        Files.copy(image.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
        
        System.out.println("üíæ Image saved to: " + targetLocation.toAbsolutePath());
        
        // Return relative URL that the frontend can use
        return "/api/products/images/" + fileName;
    }

    @GetMapping("/images/{filename:.+}")
    public ResponseEntity<byte[]> getImage(@PathVariable String filename) {
        try {
            System.out.println("üñºÔ∏è Requesting image: " + filename);
            
            Path filePath = Paths.get(UPLOAD_DIR).resolve(filename).normalize();
            
            // Security check - ensure the file is within the upload directory
            if (!filePath.startsWith(Paths.get(UPLOAD_DIR).normalize())) {
                System.err.println("‚ùå Security violation: Attempted path traversal");
                return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
            }
            
            // Check if file exists
            if (!Files.exists(filePath)) {
                System.err.println("‚ùå Image not found: " + filePath.toAbsolutePath());
                
                // Return a default image or 404
                return ResponseEntity.notFound().build();
            }
            
            byte[] imageBytes = Files.readAllBytes(filePath);
            
            // Determine content type
            String contentType = Files.probeContentType(filePath);
            if (contentType == null) {
                // Fallback based on file extension
                if (filename.toLowerCase().endsWith(".png")) {
                    contentType = "image/png";
                } else if (filename.toLowerCase().endsWith(".jpg") || filename.toLowerCase().endsWith(".jpeg")) {
                    contentType = "image/jpeg";
                } else if (filename.toLowerCase().endsWith(".gif")) {
                    contentType = "image/gif";
                } else {
                    contentType = "application/octet-stream";
                }
            }
            
            System.out.println("‚úÖ Serving image: " + filename + ", Content-Type: " + contentType + ", Size: " + imageBytes.length + " bytes");
            
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(contentType))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + filename + "\"")
                    .body(imageBytes);
                    
        } catch (IOException e) {
            System.err.println("‚ùå Error serving image: " + e.getMessage());
            return ResponseEntity.notFound().build();
        }
    }

    // Test endpoint to check image directory
    @GetMapping("/test/images")
    public ResponseEntity<?> testImageEndpoint() {
        try {
            Path uploadPath = Paths.get(UPLOAD_DIR);
            boolean exists = Files.exists(uploadPath);
            
            // List files in directory
            String[] files = null;
            if (exists) {
                files = Files.list(uploadPath)
                    .map(path -> path.getFileName().toString())
                    .toArray(String[]::new);
            }
            
            return ResponseEntity.ok(Map.of(
                "uploadDir", UPLOAD_DIR,
                "directoryExists", exists,
                "absolutePath", uploadPath.toAbsolutePath().toString(),
                "files", files != null ? files : new String[0],
                "fileCount", files != null ? files.length : 0
            ));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(Map.of("error", e.getMessage()));
        }
    }
}