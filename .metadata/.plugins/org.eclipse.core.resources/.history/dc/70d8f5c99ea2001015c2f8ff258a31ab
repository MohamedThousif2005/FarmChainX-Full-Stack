package com.farmchainx.backend.controller;

import com.farmchainx.backend.dto.ProductDTO;
import com.farmchainx.backend.entity.Product;
import com.farmchainx.backend.service.ProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import jakarta.annotation.PostConstruct;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/products")
@CrossOrigin(origins = "*")
public class ProductController {
    
    @Autowired
    private ProductService productService;

    // Use absolute path to be sure
    private final String UPLOAD_DIR = System.getProperty("user.dir") + "/uploads/products/";
    
    @PostConstruct
    public void init() {
        try {
            Path uploadPath = Paths.get(UPLOAD_DIR);
            System.out.println("üîÑ Initializing upload directory...");
            System.out.println("üìÅ Target directory: " + uploadPath.toAbsolutePath());
            
            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
                System.out.println("‚úÖ Created upload directory: " + uploadPath.toAbsolutePath());
            } else {
                System.out.println("üìÅ Upload directory already exists: " + uploadPath.toAbsolutePath());
            }
            
            // Test if we can write to the directory
            Path testFile = uploadPath.resolve("test-write.txt");
            Files.writeString(testFile, "Test write operation");
            Files.delete(testFile);
            System.out.println("‚úÖ Directory is writable");
            
        } catch (IOException e) {
            System.err.println("‚ùå Could not create upload directory: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    // Get all available products for consumers
    @GetMapping("/available")
    public ResponseEntity<?> getAvailableProducts() {
        try {
            System.out.println("üõí Fetching available products for consumers...");
            List<ProductDTO> products = productService.getAllAvailableProducts();
            System.out.println("‚úÖ Found " + products.size() + " available products");
            return ResponseEntity.ok(products);
        } catch (Exception e) {
            System.err.println("‚ùå Error fetching available products: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                Map.of("message", "Failed to fetch available products: " + e.getMessage())
            );
        }
    }
    
    // Get all products
    @GetMapping
    public ResponseEntity<?> getAllProducts() {
        try {
            System.out.println("üì¶ Fetching all products...");
            List<ProductDTO> products = productService.getAllAvailableProducts();
            System.out.println("‚úÖ Found " + products.size() + " products");
            return ResponseEntity.ok(products);
        } catch (Exception e) {
            System.err.println("‚ùå Error fetching all products: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                Map.of("message", "Failed to fetch products: " + e.getMessage())
            );
        }
    }
    
    @PostMapping(value = "/distributor/{distributorId}", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> addProduct(
            @PathVariable Long distributorId,
            @RequestParam("name") String name,
            @RequestParam("description") String description,
            @RequestParam("category") String category,
            @RequestParam("price") Double price,
            @RequestParam("quantity") Integer quantity,
            @RequestParam("unit") String unit,
            @RequestParam(value = "image", required = false) MultipartFile image) {
        
        try {
            System.out.println("üì¶ Adding product for distributor: " + distributorId);
            
            ProductDTO productDTO = new ProductDTO();
            productDTO.setName(name);
            productDTO.setDescription(description);
            productDTO.setCategory(category);
            productDTO.setPrice(price);
            productDTO.setQuantity(quantity);
            productDTO.setUnit(unit);

            // Handle image upload
            if (image != null && !image.isEmpty()) {
                System.out.println("üñºÔ∏è Image received: " + image.getOriginalFilename() + 
                                 ", Size: " + image.getSize() + 
                                 ", Type: " + image.getContentType());
                
                String imageUrl = saveImage(image);
                productDTO.setImageUrl(imageUrl);
                System.out.println("‚úÖ Image saved with URL: " + imageUrl);
            } else {
                System.out.println("‚ÑπÔ∏è No image provided");
                productDTO.setImageUrl(null);
            }

            Product product = productService.addProduct(productDTO, distributorId);
            System.out.println("‚úÖ Product added successfully with ID: " + product.getId());
            
            return ResponseEntity.ok(product);
            
        } catch (Exception e) {
            System.err.println("‚ùå Error adding product: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to add product: " + e.getMessage())
            );
        }
    }

    @GetMapping("/distributor/{distributorId}")
    public ResponseEntity<List<ProductDTO>> getDistributorProducts(@PathVariable Long distributorId) {
        try {
            List<ProductDTO> products = productService.getProductsByDistributor(distributorId);
            return ResponseEntity.ok(products);
        } catch (Exception e) {
            System.err.println("‚ùå Error fetching products: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(List.of());
        }
    }
    
    @PutMapping(value = "/{productId}", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<?> updateProduct(
            @PathVariable Long productId,
            @RequestParam("name") String name,
            @RequestParam("description") String description,
            @RequestParam("category") String category,
            @RequestParam("price") Double price,
            @RequestParam("quantity") Integer quantity,
            @RequestParam("unit") String unit,
            @RequestParam(value = "image", required = false) MultipartFile image) {
        
        try {
            ProductDTO productDTO = new ProductDTO();
            productDTO.setName(name);
            productDTO.setDescription(description);
            productDTO.setCategory(category);
            productDTO.setPrice(price);
            productDTO.setQuantity(quantity);
            productDTO.setUnit(unit);

            if (image != null && !image.isEmpty()) {
                String imageUrl = saveImage(image);
                productDTO.setImageUrl(imageUrl);
            }

            Product product = productService.updateProduct(productId, productDTO);
            return ResponseEntity.ok(product);
            
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to update product: " + e.getMessage())
            );
        }
    }
    
    @DeleteMapping("/{productId}")
    public ResponseEntity<?> deleteProduct(@PathVariable Long productId) {
        try {
            String result = productService.deleteProduct(productId);
            return ResponseEntity.ok(Map.of("message", result));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to delete product: " + e.getMessage())
            );
        }
    }

    @GetMapping("/{productId}")
    public ResponseEntity<?> getProductById(@PathVariable Long productId) {
        try {
            ProductDTO product = productService.getProductById(productId);
            return ResponseEntity.ok(product);
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(
                Map.of("message", "Failed to get product: " + e.getMessage())
            );
        }
    }

    private String saveImage(MultipartFile image) throws IOException {
        System.out.println("üíæ Starting image save process...");
        
        // Create upload directory if it doesn't exist
        Path uploadPath = Paths.get(UPLOAD_DIR);
        if (!Files.exists(uploadPath)) {
            System.out.println("üìÅ Creating upload directory: " + uploadPath.toAbsolutePath());
            Files.createDirectories(uploadPath);
        }
        
        // Generate unique filename
        String originalFileName = image.getOriginalFilename();
        System.out.println("üìÑ Original filename: " + originalFileName);
        
        String fileName = System.currentTimeMillis() + "_" + 
                         (originalFileName != null ? 
                          originalFileName.replaceAll("[^a-zA-Z0-9.-]", "_") : "product");
        
        System.out.println("üìÑ Generated filename: " + fileName);
        
        // Save file
        Path targetLocation = uploadPath.resolve(fileName);
        System.out.println("üíæ Saving to: " + targetLocation.toAbsolutePath());
        
        Files.copy(image.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
        
        // Verify the file was saved
        boolean fileExists = Files.exists(targetLocation);
        long fileSize = Files.size(targetLocation);
        
        System.out.println("‚úÖ File saved successfully!");
        System.out.println("üìÅ File exists: " + fileExists);
        System.out.println("üìè File size: " + fileSize + " bytes");
        System.out.println("üîó Image URL will be: /api/products/images/" + fileName);
        
        return "/api/products/images/" + fileName;
    }

    @GetMapping("/images/{filename:.+}")
    public ResponseEntity<byte[]> getImage(@PathVariable String filename) {
        try {
            System.out.println("üñºÔ∏è Requesting image: " + filename);
            
            Path filePath = Paths.get(UPLOAD_DIR).resolve(filename).normalize();
            System.out.println("üìÅ Looking for file at: " + filePath.toAbsolutePath());
            
            // Check if file exists
            if (!Files.exists(filePath)) {
                System.err.println("‚ùå Image not found: " + filePath.toAbsolutePath());
                return ResponseEntity.notFound().build();
            }
            
            byte[] imageBytes = Files.readAllBytes(filePath);
            System.out.println("‚úÖ Image found, size: " + imageBytes.length + " bytes");
            
            // Determine content type
            String contentType = Files.probeContentType(filePath);
            if (contentType == null) {
                if (filename.toLowerCase().endsWith(".png")) {
                    contentType = "image/png";
                } else if (filename.toLowerCase().endsWith(".jpg") || filename.toLowerCase().endsWith(".jpeg")) {
                    contentType = "image/jpeg";
                } else if (filename.toLowerCase().endsWith(".gif")) {
                    contentType = "image/gif";
                } else {
                    contentType = "application/octet-stream";
                }
            }
            
            System.out.println("‚úÖ Serving image: " + filename + ", Content-Type: " + contentType);
            
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(contentType))
                    .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + filename + "\"")
                    .body(imageBytes);
                    
        } catch (IOException e) {
            System.err.println("‚ùå Error serving image: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.notFound().build();
        }
    }

    // Test endpoint to check image directory
    @GetMapping("/test/images")
    public ResponseEntity<?> testImageEndpoint() {
        try {
            Path uploadPath = Paths.get(UPLOAD_DIR);
            boolean exists = Files.exists(uploadPath);
            
            String[] files = new String[0];
            long totalSize = 0;
            
            if (exists) {
                files = Files.list(uploadPath)
                    .map(path -> {
                        try {
                            String fileName = path.getFileName().toString();
                            long size = Files.size(path);
                            String modified = Files.getLastModifiedTime(path).toString();
                            return fileName + " (" + size + " bytes, modified: " + modified + ")";
                        } catch (IOException e) {
                            return path.getFileName().toString() + " (error)";
                        }
                    })
                    .toArray(String[]::new);
                totalSize = Files.list(uploadPath).mapToLong(path -> {
                    try {
                        return Files.size(path);
                    } catch (IOException e) {
                        return 0;
                    }
                }).sum();
            }
            
            return ResponseEntity.ok(Map.of(
                "uploadDir", UPLOAD_DIR,
                "directoryExists", exists,
                "absolutePath", uploadPath.toAbsolutePath().toString(),
                "files", files,
                "fileCount", files.length,
                "totalSize", totalSize + " bytes",
                "user.dir", System.getProperty("user.dir")
            ));
        } catch (Exception e) {
            return ResponseEntity.badRequest().body(Map.of("error", e.getMessage()));
        }
    }
}